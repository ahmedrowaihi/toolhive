package main

import (
	"context"
	"fmt"
	"os"
	"os/exec"
	"strings"
	"syscall"

	"github.com/spf13/cobra"

	"github.com/stacklok/toolhive/pkg/authz"
	"github.com/stacklok/toolhive/pkg/process"
	"github.com/stacklok/toolhive/pkg/runner"
	"github.com/stacklok/toolhive/pkg/secrets"
)

// RunMCPServer runs an MCP server with the specified config
//
//nolint:gocyclo // This function is complex but manageable
func RunMCPServer(ctx context.Context, cmd *cobra.Command, config *runner.RunConfig, foreground bool) error {
	// If not running in foreground mode, start a new detached process and exit
	if !foreground {
		return detachProcess(cmd, config)
	}

	// Create a Runner with the RunConfig
	mcpRunner := runner.NewRunner(config)

	// Run the MCP server
	return mcpRunner.Run(ctx)
}

// detachProcess starts a new detached process with the same command but with the --foreground flag
//
//nolint:gocyclo // This function is complex but manageable
func detachProcess(cmd *cobra.Command, options *runner.RunConfig) error {
	// Get the current executable path
	execPath, err := os.Executable()
	if err != nil {
		return fmt.Errorf("failed to get executable path: %v", err)
	}

	// Create a log file for the detached process
	logFilePath := fmt.Sprintf("/tmp/toolhive-%s.log", options.BaseName)
	// #nosec G304 - This is safe as baseName is generated by the application
	logFile, err := os.OpenFile(logFilePath, os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0600)
	if err != nil {
		fmt.Printf("Warning: Failed to create log file: %v\n", err)
	} else {
		defer logFile.Close()
		fmt.Printf("Logging to: %s\n", logFilePath)
	}

	// Prepare the command arguments for the detached process
	// We'll run the same command but with the --foreground flag
	detachedArgs := []string{"run", "--foreground"}

	// Add all the original flags
	if options.Transport != "stdio" {
		detachedArgs = append(detachedArgs, "--transport", string(options.Transport))
	}

	// Use Name if available
	if options.Name != "" {
		detachedArgs = append(detachedArgs, "--name", options.Name)
	}

	if options.Port != 0 {
		detachedArgs = append(detachedArgs, "--port", fmt.Sprintf("%d", options.Port))
	}
	if options.TargetPort != 0 {
		detachedArgs = append(detachedArgs, "--target-port", fmt.Sprintf("%d", options.TargetPort))
	}

	// Add target host if it's not the default
	if options.TargetHost != "localhost" {
		detachedArgs = append(detachedArgs, "--target-host", options.TargetHost)
	}

	// Pass the permission profile to the detached process
	if options.PermissionProfile != nil {
		// We need to create a temporary file for the permission profile
		permProfilePath, err := createPermissionProfileFile(options.BaseName, options.PermissionProfile, options.Debug)
		if err != nil {
			fmt.Printf("Warning: Failed to create permission profile file: %v\n", err)
		} else {
			detachedArgs = append(detachedArgs, "--permission-profile", permProfilePath)
		}
	}

	// Add environment variables
	for key, value := range options.EnvVars {
		detachedArgs = append(detachedArgs, "--env", fmt.Sprintf("%s=%s", key, value))
	}

	// Add volume mounts if they were provided
	for _, volume := range options.Volumes {
		detachedArgs = append(detachedArgs, "--volume", volume)
	}

	// Add secrets if they were provided
	for _, secret := range options.Secrets {
		detachedArgs = append(detachedArgs, "--secret", secret)
	}

	// Add OIDC flags if they were provided
	if options.OIDCConfig != nil {
		if options.OIDCConfig.Issuer != "" {
			detachedArgs = append(detachedArgs, "--oidc-issuer", options.OIDCConfig.Issuer)
		}
		if options.OIDCConfig.Audience != "" {
			detachedArgs = append(detachedArgs, "--oidc-audience", options.OIDCConfig.Audience)
		}
		if options.OIDCConfig.JWKSURL != "" {
			detachedArgs = append(detachedArgs, "--oidc-jwks-url", options.OIDCConfig.JWKSURL)
		}
		if options.OIDCConfig.ClientID != "" {
			detachedArgs = append(detachedArgs, "--oidc-client-id", options.OIDCConfig.ClientID)
		}
	}

	// Add the image and any arguments
	detachedArgs = append(detachedArgs, options.Image)
	if len(options.CmdArgs) > 0 {
		detachedArgs = append(detachedArgs, options.CmdArgs...)
	}

	// Create a new command
	// #nosec G204 - This is safe as execPath is the path to the current binary
	detachedCmd := exec.Command(execPath, detachedArgs...)

	// Set environment variables for the detached process
	detachedCmd.Env = append(os.Environ(), "TOOLHIVE_DETACHED=1")

	// If the process needs the decrypt password, pass it as an environment variable.
	if NeedSecretsPassword(cmd, options.Secrets) {
		password, err := secrets.GetSecretsPassword()
		if err != nil {
			return fmt.Errorf("failed to get secrets password: %v", err)
		}

		detachedCmd.Env = append(detachedCmd.Env, fmt.Sprintf("%s=%s", secrets.PasswordEnvVar, password))
	}

	// Redirect stdout and stderr to the log file if it was created successfully
	if logFile != nil {
		detachedCmd.Stdout = logFile
		detachedCmd.Stderr = logFile
	} else {
		// Otherwise, discard the output
		detachedCmd.Stdout = nil
		detachedCmd.Stderr = nil
	}

	// Detach the process from the terminal
	detachedCmd.Stdin = nil
	detachedCmd.SysProcAttr = &syscall.SysProcAttr{
		Setsid: true, // Create a new session
	}

	// Start the detached process
	if err := detachedCmd.Start(); err != nil {
		return fmt.Errorf("failed to start detached process: %v", err)
	}

	// Write the PID to a file so the stop command can kill the process
	if err := process.WritePIDFile(options.BaseName, detachedCmd.Process.Pid); err != nil {
		fmt.Printf("Warning: Failed to write PID file: %v\n", err)
	}

	fmt.Printf("MCP server is running in the background (PID: %d)\n", detachedCmd.Process.Pid)
	fmt.Printf("Use 'toolhive stop %s' to stop the server\n", options.Name)

	return nil
}

func findEnvironmentVariableFromSecrets(secs []string, envVarName string) bool {
	for _, secret := range secs {
		if isSecretReferenceEnvVar(secret, envVarName) {
			return true
		}
	}

	return false
}

// configureRunConfig configures a RunConfig with transport, ports, permissions, etc.
func configureRunConfig(
	cmd *cobra.Command,
	config *runner.RunConfig,
	transport string,
	port int,
	targetPort int,
	targetHost string,
	envVarStrings []string,
) error {
	var err error

	// Check if permission profile is provided
	if config.PermissionProfileNameOrPath == "" {
		return fmt.Errorf("permission profile is required")
	}

	// Process secrets if provided
	if len(config.Secrets) > 0 {
		providerType, err := GetSecretsProviderType(cmd)
		if err != nil {
			return fmt.Errorf("error determining secrets provider type: %w", err)
		}

		secretManager, err := secrets.CreateSecretManager(providerType)
		if err != nil {
			return fmt.Errorf("error instantiating secret manager %v", err)
		}

		// Process secrets
		if _, err = config.WithSecrets(secretManager); err != nil {
			return err
		}
	}

	// Set transport
	if _, err = config.WithTransport(transport); err != nil {
		return err
	}

	// Configure ports and target host
	if _, err = config.WithPorts(port, targetPort); err != nil {
		return err
	}

	// Set target host
	config.TargetHost = targetHost

	// Set permission profile (mandatory)
	if _, err = config.ParsePermissionProfile(); err != nil {
		return err
	}

	// Process volume mounts
	if err = config.ProcessVolumeMounts(); err != nil {
		return err
	}

	// Parse and set environment variables
	if _, err = config.WithEnvironmentVariables(envVarStrings); err != nil {
		return err
	}

	// Generate container name if not already set
	config.WithContainerName()

	// Add standard labels
	config.WithStandardLabels()

	// Add authorization configuration if provided
	if config.AuthzConfigPath != "" {
		authzConfig, err := authz.LoadConfig(config.AuthzConfigPath)
		if err != nil {
			return fmt.Errorf("failed to load authorization configuration: %v", err)
		}
		config.WithAuthz(authzConfig)
	}

	return nil
}

func isSecretReferenceEnvVar(secret, envVarName string) bool {
	parts := strings.Split(secret, ",")
	if len(parts) != 2 {
		return false
	}

	targetSplit := strings.Split(parts[1], "=")
	if len(targetSplit) != 2 {
		return false
	}

	if targetSplit[1] == envVarName {
		return true
	}

	return false
}
